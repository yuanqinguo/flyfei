# 第12讲：综合实战 - 社交媒体点赞关注系统


# 一、课时目标

完成本节后可以：

* 综合运用 Redis 所有核心数据结构解决真实业务问题
* 掌握多数据结构组合设计的思维模式
* 理解社交系统的核心数据流与缓存策略
* 完成可运行的完整 Go 项目
* 具备生产级 Redis 架构设计能力

---

# 二、项目需求分析

## 2.1 功能清单

| 模块 | 功能 | 涉及技术 |
|------|------|---------|
| 点赞系统 | 点赞/取消点赞、统计 | String, Set |
| 关注系统 | 关注/取消关注、双向关系 | Set |
| 热度排行榜 | 实时热度排名 | Sorted Set |
| 活跃用户统计 | 日活/周活统计 | Bitmap, HyperLogLog |
| 性能优化 | 批量操作、原子性保障 | Pipeline, Lua |

## 2.2 业务场景

```
用户 A 关注了用户 B
    ↓
用户 B 发布新文章
    ↓
用户 A 收到动态（后续课程扩展，本节只存关系）
    ↓
用户 C 给用户 B 的文章点赞
    ↓
文章热度上升，进入排行榜
```

---

# 三、数据建模设计

## 3.1 Key 命名规范

```
业务:对象:标识:属性

示例：
user:123:profile       # 用户资料
article:456:content    # 文章内容
like:article:456       # 文章点赞用户集合
follow:123:following   # 用户123的关注列表
rank:daily:20240115    # 每日热度榜
```

## 3.2 核心 Key 设计

| 功能 | Key 模式 | 数据结构 |
|------|---------|---------|
| 用户资料 | `user:{id}:profile` | Hash |
| 文章信息 | `article:{id}:meta` | Hash |
| 文章点赞 | `like:article:{id}` | Set |
| 用户关注 | `follow:{id}:following` | Set |
| 用户粉丝 | `follow:{id}:followers` | Set |
| 热度排行 | `rank:article:daily` | Sorted Set |
| 日活统计 | `dau:{yyyyMMdd}` | Bitmap |
| 用户签到 | `sign:{id}:{yyyyMM}` | Bitmap |

---

# 四、模块实现

## 4.1 用户资料系统（Hash）

### 为什么用 Hash

```
对比 String：
String: SET user:1 "{\"name\":\"张三\",\"age\":20}" 
        → 修改年龄需要整体重写

Hash:   HSET user:1 name 张三 age 20
        → HINCRBY user:1 age 1  单独修改
        → 内存更省，操作更细粒度
```

### Go 实现

```go
package service

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
)

type UserProfile struct {
	UserID    int64  `json:"user_id"`
	Nickname  string `json:"nickname"`
	Avatar    string `json:"avatar"`
	Bio       string `json:"bio"`
	Followers int64  `json:"followers"`
	Following int64  `json:"following"`
}

type UserService struct {
	rdb *redis.Client
}

func NewUserService(rdb *redis.Client) *UserService {
	return &UserService{rdb: rdb}
}

func (s *UserService) UpdateProfile(ctx context.Context, profile *UserProfile) error {
	key := fmt.Sprintf("user:%d:profile", profile.UserID)
	
	// Hash 存储，字段独立更新
	return s.rdb.HSet(ctx, key, map[string]interface{}{
		"nickname":  profile.Nickname,
		"avatar":    profile.Avatar,
		"bio":       profile.Bio,
		"update_at": time.Now().Unix(),
	}).Err()
}

func (s *UserService) GetProfile(ctx context.Context, userID int64) (*UserProfile, error) {
	key := fmt.Sprintf("user:%d:profile", userID)
	
	data, err := s.rdb.HGetAll(ctx, key).Result()
	if err != nil {
		return nil, err
	}
	if len(data) == 0 {
		// 缓存未命中，从数据库加载（模拟）
		return s.loadFromDB(ctx, userID)
	}
	
	return &UserProfile{
		UserID:   userID,
		Nickname: data["nickname"],
		Avatar:   data["avatar"],
		Bio:      data["bio"],
	}, nil
}

// 粉丝数/关注数用 String 存储，便于原子操作
func (s *UserService) IncrFollowers(ctx context.Context, userID int64) error {
	key := fmt.Sprintf("user:%d:followers", userID)
	return s.rdb.Incr(ctx, key).Err()
}
```

---

## 4.2 点赞系统（Set + String）

### 设计要点

```
like:article:{id}  → Set 存储点赞用户ID（去重、判断存在）
article:{id}:count → String 存储点赞数（快速读取、原子增减）
```

### 为什么这样设计

| 需求 | 数据结构 | 原因 |
|------|---------|------|
| 判断是否点赞 | Set | SISMEMBER O(1) |
| 点赞用户列表 | Set | SMEMBERS |
| 点赞总数展示 | String | GET O(1)，避免 SCARD 计算 |
| 高并发计数 | String | INCR 原子操作 |

### Go 实现

```go
package service

import (
	"context"
	"fmt"

	"github.com/redis/go-redis/v9"
)

type LikeService struct {
	rdb *redis.Client
}

func NewLikeService(rdb *redis.Client) *LikeService {
	return &LikeService{rdb: rdb}
}

// 点赞 - 使用 Lua 保证原子性
var likeScript = redis.NewScript(`
	local userKey = KEYS[1]
	local countKey = KEYS[2]
	local userID = ARGV[1]
	
	-- 判断是否已点赞
	if redis.call('SISMEMBER', userKey, userID) == 1 then
		return 0  -- 已点赞
	end
	
	-- 添加点赞用户，增加计数
	redis.call('SADD', userKey, userID)
	redis.call('INCR', countKey)
	return 1
`)

func (s *LikeService) Like(ctx context.Context, articleID, userID int64) (bool, error) {
	userKey := fmt.Sprintf("like:article:%d", articleID)
	countKey := fmt.Sprintf("article:%d:like_count", articleID)
	
	result, err := likeScript.Run(ctx, s.rdb, 
		[]string{userKey, countKey}, 
		userID,
	).Int()
	
	return result == 1, err
}

// 取消点赞
var unlikeScript = redis.NewScript(`
	local userKey = KEYS[1]
	local countKey = KEYS[2]
	local userID = ARGV[1]
	
	if redis.call('SISMEMBER', userKey, userID) == 0 then
		return 0  -- 未点赞
	end
	
	redis.call('SREM', userKey, userID)
	redis.call('DECR', countKey)
	return 1
`)

func (s *LikeService) Unlike(ctx context.Context, articleID, userID int64) (bool, error) {
	userKey := fmt.Sprintf("like:article:%d", articleID)
	countKey := fmt.Sprintf("article:%d:like_count", articleID)
	
	result, err := unlikeScript.Run(ctx, s.rdb,
		[]string{userKey, countKey},
		userID,
	).Int()
	
	return result == 1, err
}

// 是否点赞
func (s *LikeService) IsLiked(ctx context.Context, articleID, userID int64) (bool, error) {
	key := fmt.Sprintf("like:article:%d", articleID)
	return s.rdb.SIsMember(ctx, key, userID).Result()
}

// 获取点赞数（String 直接读取，O(1)）
func (s *LikeService) GetLikeCount(ctx context.Context, articleID int64) (int64, error) {
	key := fmt.Sprintf("article:%d:like_count", articleID)
	return s.rdb.Get(ctx, key).Int64()
}

// 获取点赞用户列表（分页）
func (s *LikeService) GetLikeUsers(ctx context.Context, articleID int64, page, size int) ([]string, error) {
	key := fmt.Sprintf("like:article:%d", articleID)
	
	// Set 转 Slice，用 SRANDMEMBER 或 SSCAN 分页
	// 这里简化，取全部（小集合适用）
	return s.rdb.SMembers(ctx, key).Result()
}
```

---

## 4.3 关注系统（Set + 关系运算）

### 双向关系设计

```
follow:{id}:following  → 我关注的人（我主动）
follow:{id}:followers  → 我的粉丝（别人主动）
```

### 社交关系计算

```
共同关注：SINTER follow:A:following follow:B:following
可能认识：SDIFF  follow:A:following follow:B:following  (B有A没有)
是否互关：SISMEMBER follow:A:following B && SISMEMBER follow:B:following A
```

### Go 实现

```go
package service

import (
	"context"
	"fmt"

	"github.com/redis/go-redis/v9"
)

type FollowService struct {
	rdb *redis.Client
}

func NewFollowService(rdb *redis.Client) *FollowService {
	return &FollowService{rdb: rdb}
}

// 关注 - 双向写，Lua 保证原子
var followScript = redis.NewScript(`
	local myFollowing = KEYS[1]
	local hisFollowers = KEYS[2]
	local targetID = ARGV[1]
	local myID = ARGV[2]
	
	-- 是否已关注
	if redis.call('SISMEMBER', myFollowing, targetID) == 1 then
		return 0
	end
	
	-- 添加关注关系
	redis.call('SADD', myFollowing, targetID)
	redis.call('SADD', hisFollowers, myID)
	return 1
`)

func (s *FollowService) Follow(ctx context.Context, userID, targetID int64) (bool, error) {
	myFollowing := fmt.Sprintf("follow:%d:following", userID)
	hisFollowers := fmt.Sprintf("follow:%d:followers", targetID)
	
	result, err := followScript.Run(ctx, s.rdb,
		[]string{myFollowing, hisFollowers},
		targetID, userID,
	).Int()
	
	return result == 1, err
}

// 取消关注
func (s *FollowService) Unfollow(ctx context.Context, userID, targetID int64) (bool, error) {
	myFollowing := fmt.Sprintf("follow:%d:following", userID)
	hisFollowers := fmt.Sprintf("follow:%d:followers", targetID)
	
	// 管道批量操作
	pipe := s.rdb.Pipeline()
	pipe.SRem(ctx, myFollowing, targetID)
	pipe.SRem(ctx, hisFollowers, userID)
	_, err := pipe.Exec(ctx)
	
	return true, err
}

// 共同关注 - 集合交集
func (s *FollowService) CommonFollowing(ctx context.Context, userA, userB int64) ([]string, error) {
	keyA := fmt.Sprintf("follow:%d:following", userA)
	keyB := fmt.Sprintf("follow:%d:following", userB)
	
	return s.rdb.SInter(ctx, keyA, keyB).Result()
}

// 是否互关
func (s *FollowService) IsMutualFollow(ctx context.Context, userA, userB int64) (bool, error) {
	keyA := fmt.Sprintf("follow:%d:following", userA)
	keyB := fmt.Sprintf("follow:%d:following", userB)
	
	// Pipeline 批量查询
	pipe := s.rdb.Pipeline()
	cmdA := pipe.SIsMember(ctx, keyA, userB)
	cmdB := pipe.SIsMember(ctx, keyB, userA)
	_, err := pipe.Exec(ctx)
	
	if err != nil {
		return false, err
	}
	
	return cmdA.Val() && cmdB.Val(), nil
}

// 获取关注数/粉丝数
func (s *FollowService) GetFollowStats(ctx context.Context, userID int64) (following, followers int64, err error) {
	keyFollowing := fmt.Sprintf("follow:%d:following", userID)
	keyFollowers := fmt.Sprintf("follow:%d:followers", userID)
	
	// 使用 SCARD 计算，或维护单独的计数器 String
	// 小集合直接用 SCARD，大集合建议单独计数器
	following, _ = s.rdb.SCard(ctx, keyFollowing).Result()
	followers, _ = s.rdb.SCard(ctx, keyFollowers).Result()
	
	return
}
```

---

## 4.4 热度排行榜（Sorted Set）

### 热度计算公式

```
score = 点赞数 * 1 + 评论数 * 2 + 分享数 * 3 + 时间衰减因子
```

简单版本：实时点赞数排行

### Go 实现

```go
package service

import (
	"context"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
)

type RankService struct {
	rdb *redis.Client
}

func NewRankService(rdb *redis.Client) *RankService {
	return &RankService{rdb: rdb}
}

// 更新文章热度
func (s *RankService) UpdateScore(ctx context.Context, articleID int64, delta float64) error {
	// 每日一个榜
	dateStr := time.Now().Format("20060102")
	key := fmt.Sprintf("rank:article:%s", dateStr)
	
	// ZINCRBY 原子增加分数
	return s.rdb.ZIncrBy(ctx, key, delta, fmt.Sprintf("%d", articleID)).Err()
}

// 获取 Top N
func (s *RankService) GetTopN(ctx context.Context, n int64) ([]redis.Z, error) {
	dateStr := time.Now().Format("20060102")
	key := fmt.Sprintf("rank:article:%s", dateStr)
	
	// ZREVRANGE 从高到低
	return s.rdb.ZRevRangeWithScores(ctx, key, 0, n-1).Result()
}

// 获取文章排名
func (s *RankService) GetArticleRank(ctx context.Context, articleID int64) (int64, error) {
	dateStr := time.Now().Format("20060102")
	key := fmt.Sprintf("rank:article:%s", dateStr)
	
	// ZREVRANK 获取排名（从0开始）
	return s.rdb.ZRevRank(ctx, key, fmt.Sprintf("%d", articleID)).Result()
}

// 点赞时触发热度更新
func (s *RankService) OnArticleLiked(ctx context.Context, articleID int64) {
	s.UpdateScore(ctx, articleID, 1) // 点赞 +1 分
}

// 设置过期（保留3天榜）
func (s *RankService) ExpireOldRanks(ctx context.Context) {
	dateStr := time.Now().AddDate(0, 0, -3).Format("20060102")
	key := fmt.Sprintf("rank:article:%s", dateStr)
	s.rdb.Expire(ctx, key, 0) // 立即过期
}
```

---

## 4.5 活跃用户统计（Bitmap + HyperLogLog）

### 日活统计（Bitmap）

```
dau:20240115  → Bitmap，第 userID 位为 1 表示活跃
优势：1亿用户只需 12MB 内存
```

### 去重统计（HyperLogLog）

```
uv:article:456  → HyperLogLog，统计浏览去重用户数
优势：1亿数据只需 12KB，误差 0.81%
```

### Go 实现

```go
package service

import (
	"context"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
)

type StatsService struct {
	rdb *redis.Client
}

func NewStatsService(rdb *redis.Client) *StatsService {
	return &StatsService{rdb: rdb}
}

// 用户签到（Bitmap）
func (s *StatsService) UserSign(ctx context.Context, userID int64, date time.Time) error {
	key := fmt.Sprintf("sign:%d:%s", userID, date.Format("200601"))
	
	// 第几天，offset 从 0 开始
	offset := int64(date.Day() - 1)
	return s.rdb.SetBit(ctx, key, offset, 1).Err()
}

// 检查是否签到
func (s *StatsService) CheckSign(ctx context.Context, userID int64, date time.Time) (int64, error) {
	key := fmt.Sprintf("sign:%d:%s", userID, date.Format("200601"))
	offset := int64(date.Day() - 1)
	return s.rdb.GetBit(ctx, key, offset).Result()
}

// 统计月签到次数
func (s *StatsService) GetMonthSignCount(ctx context.Context, userID int64, month time.Time) (int64, error) {
	key := fmt.Sprintf("sign:%d:%s", userID, month.Format("200601"))
	return s.rdb.BitCount(ctx, key).Result()
}

// 记录日活（Bitmap）
func (s *StatsService) RecordDAU(ctx context.Context, userID int64) error {
	dateStr := time.Now().Format("20060102")
	key := fmt.Sprintf("dau:%s", dateStr)
	return s.rdb.SetBit(ctx, key, userID, 1).Err()
}

// 获取日活人数
func (s *StatsService) GetDAU(ctx context.Context, date time.Time) (int64, error) {
	key := fmt.Sprintf("dau:%s", date.Format("20060102"))
	return s.rdb.BitCount(ctx, key).Result()
}

// 记录文章 UV（HyperLogLog）
func (s *StatsService) RecordArticleUV(ctx context.Context, articleID, userID int64) error {
	key := fmt.Sprintf("uv:article:%d", articleID)
	return s.rdb.PFAdd(ctx, key, userID).Err()
}

// 获取文章 UV
func (s *StatsService) GetArticleUV(ctx context.Context, articleID int64) (int64, error) {
	key := fmt.Sprintf("uv:article:%d", articleID)
	return s.rdb.PFCount(ctx, key).Result()
}

// 合并多日 UV（HyperLogLog 合并）
func (s *StatsService) MergeUV(ctx context.Context, dest string, sources ...string) error {
	return s.rdb.PFMerge(ctx, dest, sources...).Err()
}
```

---

## 4.6 批量操作与性能优化（Pipeline）

```go
package service

import (
	"context"
	"fmt"

	"github.com/redis/go-redis/v9"
)

// FeedService 动态服务 - 使用 Pipeline 批量获取
type FeedService struct {
	rdb *redis.Client
}

func NewFeedService(rdb *redis.Client) *FeedService {
	return &FeedService{rdb: rdb}
}

// GetFollowingsFeed 获取关注人的最新文章（简化版）
func (s *FeedService) GetFollowingsFeed(ctx context.Context, userID int64, page, size int) ([]ArticleMeta, error) {
	// 1. 获取关注列表
	followKey := fmt.Sprintf("follow:%d:following", userID)
	following, err := s.rdb.SMembers(ctx, followKey).Result()
	if err != nil {
		return nil, err
	}
	
	// 2. Pipeline 批量获取用户信息
	pipe := s.rdb.Pipeline()
	cmds := make([]*redis.MapStringStringCmd, len(following))
	for i, uid := range following {
		key := fmt.Sprintf("user:%s:profile", uid)
		cmds[i] = pipe.HGetAll(ctx, key)
	}
	_, err = pipe.Exec(ctx)
	if err != nil {
		return nil, err
	}
	
	// 3. 解析结果（实际业务还需查询文章列表）
	results := make([]ArticleMeta, 0, len(following))
	for i, cmd := range cmds {
		data := cmd.Val()
		if len(data) > 0 {
			results = append(results, ArticleMeta{
				AuthorID: following[i],
				AuthorName: data["nickname"],
			})
		}
	}
	
	return results, nil
}

type ArticleMeta struct {
	AuthorID   string
	AuthorName string
	Title      string
	LikeCount  int64
}
```

---

# 五、项目结构

```
social-app/
├── cmd/
│   └── api/
│       └── main.go          # 入口
├── internal/
│   ├── handler/             # HTTP handler
│   │   ├── user.go
│   │   ├── like.go
│   │   ├── follow.go
│   │   └── rank.go
│   ├── service/             # 业务逻辑（上面代码）
│   │   ├── user.go
│   │   ├── like.go
│   │   ├── follow.go
│   │   ├── rank.go
│   │   ├── stats.go
│   │   └── feed.go
│   └── model/
│       └── types.go
├── pkg/
│   └── redis/
│       └── client.go        # Redis 初始化
├── docker-compose.yml       # Redis 部署
└── go.mod
```

---

# 六、Redis 初始化配置

```go
// pkg/redis/client.go
package redis

import (
	"github.com/redis/go-redis/v9"
)

func NewClient() *redis.Client {
	return redis.NewClient(&redis.Options{
		Addr:         "localhost:6379",
		PoolSize:     20,
		MinIdleConns: 5,
	})
}
```


# 七、本节课堂任务

必须完成：

1. **搭建项目**：创建完整目录结构，初始化 Go 模块
2. **实现点赞**：完成 Like/Unlike/IsLiked 三个接口
3. **实现关注**：完成 Follow/Unfollow，查询共同关注
4. **排行榜**：实现 Top10 查询，测试热度更新
5. **统计功能**：用 Bitmap 实现签到，用 HyperLogLog 统计 UV
6. **压测**：对比 Pipeline 和普通模式在批量获取下的性能差异

---

# 八、数据结构使用总结

| 数据结构 | 本讲应用场景 | 选择理由 |
|---------|-----------|---------|
| **String** | 点赞计数、粉丝计数 | 原子 INCR，O(1) 读取 |
| **Hash** | 用户资料 | 字段独立更新，省内存 |
| **Set** | 点赞用户、关注关系 | 去重、交并差运算 |
| **Sorted Set** | 热度排行榜 | 自动排序，范围查询 |
| **Bitmap** | 日活、签到 | 极致省内存，位运算 |
| **HyperLogLog** | UV 统计 | 海量数据去重，固定内存 |
| **Pipeline** | 批量获取 | 减少 RTT |
| **Lua** | 点赞、关注原子性 | 多操作原子执行 |

---

# 九、课程总结

你已经完成：

✅ **第1-10讲**：掌握 Redis 核心数据结构、通信机制、持久化、事务

✅ **第11讲**：性能优化、高可用架构、缓存问题防御

✅ **第12讲**：完整社交系统实战，综合运用所有技术

你现在具备：

* 根据业务场景选择合适数据结构的能力
* 设计高并发、高可用 Redis 架构的思维
* 使用 Go + Redis 开发生产级后端服务的能力