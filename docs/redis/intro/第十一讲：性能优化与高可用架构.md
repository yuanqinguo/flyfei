# 第11讲：性能优化与高可用架构


# 一、课时目标

完成本节后可以：

* 理解 Pipeline 批量操作的原理和收益
* 掌握 Lua 脚本优化的原子场景
* 理解连接池设计的必要性
* 掌握主从复制、Sentinel、Cluster 三种高可用架构
* 理解缓存雪崩、击穿、穿透的原因与防御方案
* 使用 Pipeline 优化接口性能并压测对比

---

# 二、为什么需要性能优化

Redis 很快，但你的代码可能很慢：

```
问题场景：
- 1000 次请求，每次 1 条命令 → 1000 次 RTT
- 复杂逻辑多次往返 Redis
- 连接频繁创建销毁
```

优化方向：

| 手段 | 解决什么问题 |
|------|-------------|
| Pipeline | 减少网络往返（RTT） |
| Lua 脚本 | 原子执行多步逻辑 |
| 连接池 | 避免连接创建开销 |

---

# 三、Pipeline：批量操作神器

## 3.1 什么是 RTT

RTT（Round Trip Time）：请求往返时间

```
客户端 ──────► Redis  发送
客户端 ◄────── Redis  返回
```

单次 RTT ≈ 0.5~2ms（内网），累积后很可观

---

## 3.2 Pipeline 原理

普通模式（1000 次）：

```
客户端 ──► 命令1 ──► 等待 ──► 结果1 ◄──
客户端 ──► 命令2 ──► 等待 ──► 结果2 ◄──
... 重复 1000 次
```

Pipeline 模式：

```
客户端 ──► 命令1、命令2、...、命令1000 ──► Redis（一次性发送）
Redis 执行完所有命令
客户端 ◄── 结果1、结果2、...、结果1000 ◄──（一次性返回）
```

优势：**1 次 RTT 完成 N 个命令**

---

## 3.3 使用场景

适用：

* 批量写入（初始化数据、批量更新）
* 批量查询（MGET 替代多次 GET）
* 非关联的多条命令

不适用：

* 命令间有依赖关系（需要上一条结果）
* 需要事务一致性检查


# 四、Lua 脚本优化

## 4.1 为什么需要 Lua

场景：库存扣减

```
1. GET 库存
2. 判断 > 0
3. DECR 库存
```

问题：三步操作，两次往返，非原子

Lua 解决：**把逻辑打包，在 Redis 服务端原子执行**

---

## 4.2 Lua 脚本特性

```
        客户端              Redis 服务端
           │                    │
           │  发送 Lua 脚本      │
           ├───────────────────►│
           │                    │  原子执行
           │                    │  （单线程）
           │  返回结果           │
           │◄───────────────────┤
```

特点：

* 原子性：整个脚本作为一个命令执行
* 减少 RTT：一次发送，一次返回
* 复用：脚本缓存在 Redis，下次只传 SHA

---

## 4.3 库存扣减实战

Lua 脚本：

```lua
-- 参数：KEYS[1]=库存key, ARGV[1]=扣减数量
local stock = tonumber(redis.call('GET', KEYS[1]) or 0)
local decr = tonumber(ARGV[1])

if stock >= decr then
    redis.call('DECRBY', KEYS[1], decr)
    return 1  -- 成功
else
    return 0  -- 库存不足
end
```

Go 调用：

```go
var decrStockScript = redis.NewScript(`
	local stock = tonumber(redis.call('GET', KEYS[1]) or 0)
	local decr = tonumber(ARGV[1])
	if stock >= decr then
		redis.call('DECRBY', KEYS[1], decr)
		return 1
	else
		return 0
	end
`)

func DecrStock(ctx context.Context, rdb *redis.Client, key string, num int) (bool, error) {
	result, err := decrStockScript.Run(ctx, rdb, []string{key}, num).Int()
	if err != nil {
		return false, err
	}
	return result == 1, nil
}
```

---

## 4.4 Pipeline vs Lua 选择

| 场景 | 选择 | 原因 |
|------|------|------|
| 批量无关联操作 | Pipeline | 简单、吞吐高 |
| 多步有逻辑判断 | Lua | 原子性、减少 RTT |
| 复杂事务 | Lua /  reconsider 架构 | Redis 事务弱 |

---

# 五、连接池设计

## 5.1 为什么需要连接池

错误做法：

```go
func Handler() {
	rdb := redis.NewClient(...) // 每次请求创建
	defer rdb.Close()
	// ...
}
```

问题：

* 连接创建开销大（TCP 握手）
* 高频场景连接数暴涨
* 耗尽 Redis 连接上限

---

## 5.2 go-redis 连接池配置

```go
rdb := redis.NewClient(&redis.Options{
	Addr: "localhost:6379",
	
	// 连接池核心配置
	PoolSize:     10,           // 连接池大小
	MinIdleConns: 5,            // 最小空闲连接
	MaxConnAge:   time.Hour,    // 连接最大存活时间
	PoolTimeout:  time.Second,  // 获取连接等待时间
	IdleTimeout:  10 * time.Minute, // 空闲连接超时
})
```

原则：

* 全局复用一个 Client（线程安全）
* 不要频繁创建关闭
* 根据 QPS 调整 PoolSize

---

# 六、高可用架构

## 6.1 单机问题

```
单点故障：
- 机器宕机 → 服务不可用
- 数据丢失 → 无法恢复
- 容量上限 → 单机内存有限
```

解决方案演进：

```
主从复制 ──► Sentinel ──► Cluster
（读写分离）  （自动故障转移）  （数据分片）
```

---

## 6.2 主从复制（Replication）

架构：

```
        ┌─────────┐
        │  Master │  ← 写操作
        │  主节点  │
        └────┬────┘
             │ 复制数据
     ┌───────┼───────┐
     ▼       ▼       ▼
 ┌──────┐ ┌──────┐ ┌──────┐
 │Slave │ │Slave │ │Slave │  ← 读操作
 │ 从节点│ │ 从节点│ │ 从节点│
 └──────┘ └──────┘ └──────┘
```

特点：

* 一主多从，读写分离
* 从节点异步复制（有延迟）
* 主节点宕机需手动切换

配置（docker-compose）：

```yaml
version: '3.9'

services:
  redis-master:
    image: redis:7
    ports:
      - "6379:6379"
  
  redis-slave:
    image: redis:7
    ports:
      - "6380:6379"
    command: redis-server --slaveof redis-master 6379
```

---

## 6.3 Sentinel（哨兵模式）

解决主从的手动切换问题：

```
        ┌─────────┐
        │ Sentinel│  监控集群
        │  哨兵   │  自动故障转移
        └────┬────┘
             │
    ┌────────┼────────┐
    ▼        ▼        ▼
┌──────┐ ┌──────┐ ┌──────┐
│Master│ │Slave │ │Slave │
│ 主   │ │ 从   │ │ 从   │
└──────┘ └──────┘ └──────┘
```

Sentinel 职责：

1. **监控**：检测主从节点健康
2. **通知**：故障时通知客户端
3. **自动故障转移**：主节点宕机，选举新主节点
4. **配置提供**：客户端向 Sentinel 获取当前主节点地址

Go 连接 Sentinel：

```go
rdb := redis.NewFailoverClient(&redis.FailoverOptions{
	MasterName:    "mymaster",
	SentinelAddrs: []string{"localhost:26379", "localhost:26380", "localhost:26381"},
})
```

---

## 6.4 Cluster（集群模式）

解决单机容量上限：

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│ Master  │  │ Master  │  │ Master  │
│  A      │  │  B      │  │  C      │
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
┌────┴────┐  ┌────┴────┐  ┌────┴────┐
│ Slave A │  │ Slave B │  │ Slave C │
│ (从A)   │  │ (从B)   │  │ (从C)   │
└─────────┘  └─────────┘  └─────────┘

数据分片：
- A 负责 0-5460 槽位
- B 负责 5461-10922 槽位  
- C 负责 10923-16383 槽位
```

特点：

* 数据分片存储（16384 个槽位）
* 水平扩展（加节点即扩容）
* 无中心架构（所有节点平等）

Go 连接 Cluster：

```go
rdb := redis.NewClusterClient(&redis.ClusterOptions{
	Addrs: []string{
		"localhost:7000",
		"localhost:7001", 
		"localhost:7002",
	},
})
```

---

## 6.5 三种架构选择

| 架构 | 数据量 | 可用性 | 复杂度 | 场景 |
|------|--------|--------|--------|------|
| 主从复制 | < 10GB | 中等 | 低 | 读多写少，可接受手动切换 |
| Sentinel | < 10GB | 高 | 中 | 生产环境推荐，自动故障转移 |
| Cluster | > 10GB 或 需要水平扩展 | 高 | 高 | 大数据量、高并发 |

---

# 七、缓存三大问题

## 7.1 缓存雪崩（Avalanche）

现象：

```
同一时间大量缓存过期
        │
        ▼
   请求全部打到数据库
        │
        ▼
   数据库宕机
```

原因：

* 批量设置相同过期时间
* Redis 宕机

防御：

```go
// 1. 过期时间加随机值
ttl := 3600 + rand.Intn(300) // 3600~3900 秒

// 2. 热点数据永不过期，主动更新
// 3. 多级缓存（Redis + LocalCache）
// 4. 熔断降级（数据库压力大时直接返回默认值）
```

---

## 7.2 缓存击穿（Breakdown）

现象：

```
热点 Key 过期瞬间
        │
        ▼
   大量请求同时查询数据库
        │
        ▼
   数据库压力激增
```

防御：

```go
// 1. 互斥锁重建（只有一个线程去加载）
func GetWithMutex(ctx context.Context, rdb *redis.Client, key string) (string, error) {
	val, err := rdb.Get(ctx, key).Result()
	if err == nil {
		return val, nil
	}
	
	// 获取分布式锁
	lockKey := key + ":lock"
	ok, err := rdb.SetNX(ctx, lockKey, 1, 10*time.Second).Result()
	if !ok {
		// 获取锁失败，短暂等待后重试
		time.Sleep(100 * time.Millisecond)
		return rdb.Get(ctx, key).Result()
	}
	
	// 只有一个线程执行到这里查数据库
	val = queryFromDB(key)
	rdb.Set(ctx, key, val, 3600*time.Second)
	rdb.Del(ctx, lockKey)
	return val, nil
}

// 2. 热点数据永不过期
```

---

## 7.3 缓存穿透（Penetration）

现象：

```
查询不存在的数据（如 id=-1）
        │
        ▼
   缓存无，数据库也无
        │
        ▼
   每次都查数据库
        │
        ▼
   攻击者构造大量无效请求
```

防御：

```go
// 1. 布隆过滤器（推荐）
// 2. 缓存空值（短期）
func GetWithNullCache(ctx context.Context, rdb *redis.Client, key string) (string, error) {
	val, err := rdb.Get(ctx, key).Result()
	if err == nil {
		return val, nil
	}
	
	// 查数据库
	val, err = queryFromDB(key)
	if err != nil {
		// 数据库也无，缓存空值 5 分钟
		rdb.Set(ctx, key, "", 5*time.Minute)
		return "", nil
	}
	
	rdb.Set(ctx, key, val, 3600*time.Second)
	return val, nil
}

// 3. 参数校验（拦截明显非法请求）
```

---

## 7.4 三者对比

| 问题 | 触发条件 | 目标 | 防御核心 |
|------|---------|------|---------|
| 雪崩 | 批量 Key 过期 | 数据库 | 分散过期时间、多级缓存 |
| 击穿 | 热点 Key 过期 | 数据库 | 互斥锁重建、永不过期 |
| 穿透 | 查询不存在 Key | 数据库 | 布隆过滤器、缓存空值 |

---

# 八、实战：Pipeline 性能优化

## 8.1 场景

批量获取用户信息接口，需要查询 100 个用户资料

---

## 8.2 普通实现

```go
func getUsersNormal(ctx context.Context, rdb *redis.Client, ids []int) ([]string, error) {
	results := make([]string, len(ids))
	for i, id := range ids {
		key := fmt.Sprintf("user:%d", id)
		val, err := rdb.Get(ctx, key).Result()
		if err == nil {
			results[i] = val
		}
	}
	return results, nil
}
```

问题：100 次 RTT

---

## 8.3 Pipeline 优化实现

```go
func getUsersPipeline(ctx context.Context, rdb *redis.Client, ids []int) ([]string, error) {
	pipe := rdb.Pipeline()
	
	// 批量添加命令
	cmds := make([]*redis.StringCmd, len(ids))
	for i, id := range ids {
		key := fmt.Sprintf("user:%d", id)
		cmds[i] = pipe.Get(ctx, key)
	}
	
	// 一次执行
	_, err := pipe.Exec(ctx)
	if err != nil && err != redis.Nil {
		return nil, err
	}
	
	// 解析结果
	results := make([]string, len(ids))
	for i, cmd := range cmds {
		val, err := cmd.Result()
		if err == nil {
			results[i] = val
		}
	}
	return results, nil
}
```

---

## 8.4 压测对比
#### benchmark.go代码
```go
package main

import (
	"context"
	"flag"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
)

var mode = flag.String("mode", "normal", "test mode: normal or pipeline")

func main() {
	flag.Parse()
	
	ctx := context.Background()
	
	// 连接 Redis
	rdb := redis.NewClient(&redis.Options{
		Addr: "localhost:6379",
	})
	defer rdb.Close()
	
	// 准备测试数据：写入 1000 个 key
	fmt.Println("准备测试数据...")
	for i := 0; i < 1000; i++ {
		rdb.Set(ctx, fmt.Sprintf("bench:%d", i), fmt.Sprintf("value-%d", i), 0)
	}
	
	// 测试参数
	ids := make([]int, 100)
	for i := 0; i < 100; i++ {
		ids[i] = i
	}
	
	iterations := 10 // 执行 10 轮取平均
	
	fmt.Printf("开始压测: mode=%s, keys=%d, iterations=%d\n\n", *mode, len(ids), iterations)
	
	var totalDuration time.Duration
	
	for i := 0; i < iterations; i++ {
		start := time.Now()
		
		if *mode == "normal" {
			getUsersNormal(ctx, rdb, ids)
		} else {
			getUsersPipeline(ctx, rdb, ids)
		}
		
		duration := time.Since(start)
		totalDuration += duration
		fmt.Printf("第 %d 轮: %v\n", i+1, duration)
	}
	
	avg := totalDuration / time.Duration(iterations)
	fmt.Printf("\n平均耗时: %v\n", avg)
	
	// 清理数据
	for i := 0; i < 1000; i++ {
		rdb.Del(ctx, fmt.Sprintf("bench:%d", i))
	}
}

// 普通模式：100 次 RTT
func getUsersNormal(ctx context.Context, rdb *redis.Client, ids []int) ([]string, error) {
	results := make([]string, len(ids))
	for i, id := range ids {
		key := fmt.Sprintf("bench:%d", id)
		val, err := rdb.Get(ctx, key).Result()
		if err == nil {
			results[i] = val
		}
	}
	return results, nil
}

// Pipeline 模式：1 次 RTT
func getUsersPipeline(ctx context.Context, rdb *redis.Client, ids []int) ([]string, error) {
	pipe := rdb.Pipeline()
	
	cmds := make([]*redis.StringCmd, len(ids))
	for i, id := range ids {
		key := fmt.Sprintf("bench:%d", id)
		cmds[i] = pipe.Get(ctx, key)
	}
	
	_, err := pipe.Exec(ctx)
	if err != nil && err != redis.Nil {
		return nil, err
	}
	
	results := make([]string, len(ids))
	for i, cmd := range cmds {
		val, err := cmd.Result()
		if err == nil {
			results[i] = val
		}
	}
	return results, nil
}
```

使用 `go test -bench`  压测：

```bash
# 普通模式
go run benchmark.go -mode=normal

# Pipeline 模式  
go run benchmark.go -mode=pipeline
```


# 九、本节课堂任务

必须完成：

1. 使用 CLI 测试 Pipeline（`redis-cli --pipe`）
2. 编写 Pipeline 批量写入程序
3. 编写 Lua 脚本实现库存扣减
4. 理解主从、Sentinel、Cluster 适用场景
5. 画出缓存雪崩、击穿、穿透的防御流程图

---

# 十、本节总结

你已经掌握：

* Pipeline 原理与实战（减少 RTT）
* Lua 脚本原子操作（复杂逻辑服务端执行）
* 连接池配置（复用连接）
* 高可用架构演进（主从 → Sentinel → Cluster）
* 缓存三大问题及防御（雪崩、击穿、穿透）

---

# 下节课

第12讲：综合实战 - 社交媒体点赞关注系统

* 强制混合使用所有数据结构
* 完整 Go 项目交付
* 大秦授课视频
