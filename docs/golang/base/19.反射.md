# 反射


  ### 1. 语法/理论讲解
  - **定义**：程序在运行时检查自身结构的能力
  - **核心**：`interface{}` + `reflect`包
  - 像程序运行时的"镜子"，能看到自己的类型信息

  **两大核心组件**
  ```go
  import "reflect"
  
  // 1. Type - 类型信息
  var x int = 42
  t := reflect.TypeOf(x)  // 获取类型信息
  
  // 2. Value - 值信息  
  v := reflect.ValueOf(x) // 获取值信息
  ```

  **关键概念**
  - **Kind**：基础类型（int、string、struct等）
  - **可设置性**：值能否被修改
  - **类型断言**：运行时类型检查

  **性能注意事项**
  - 反射比直接调用慢10-100倍
  - 生产环境避免在热点路径使用
  - 可提前缓存反射结果

  ### 2. 应用场景

  1. **框架开发**
  - Web框架中的路由绑定和参数解析
  - 各类注入的中间件

  2. **配置解析**
  - JSON/YAML配置文件 → 结构体
  - 根据字段标签动态映射

  3. **序列化/反序列化**
  - JSON、XML编码解码
  - 数据库ORM映射

  4. **依赖注入**
  - 自动创建对象实例
  - 解析依赖关系

---

  ### 3. 编程示例

  **通用配置管理**
  ```go
  type Config struct {
      AppName    string `config:"app_name" default:"MyApp"`
      Port       int    `config:"port" default:"8080"`
      Debug      bool   `config:"debug" default:"false"`
  }
  
  type ConfigManager struct {
      config interface{}
  }
  
  func (cm *ConfigManager) LoadFromMap(data map[string]string) error {
      v := reflect.ValueOf(cm.config).Elem()
      t := v.Type()
      
      for i := 0; i < v.NumField(); i++ {
          field := v.Field(i)
          fieldType := t.Field(i)
          
          // 获取标签值
          configKey := fieldType.Tag.Get("config")
          defaultValue := fieldType.Tag.Get("default")
          
          // 根据字段类型设置值
          valueStr := data[configKey]
          if valueStr == "" {
              valueStr = defaultValue
          }
          
          // 类型转换和设值逻辑
          switch field.Kind() {
          case reflect.String:
              field.SetString(valueStr)
          case reflect.Int:
              if value, err := strconv.Atoi(valueStr); err == nil {
                  field.SetInt(int64(value))
              }
          case reflect.Bool:
              value := strings.ToLower(valueStr) == "true"
              field.SetBool(value)
          }
      }
      return nil
  }
  
  // 使用示例
  func main() {
      config := &Config{}
      manager := NewConfigManager(config)
      
      configData := map[string]string{
          "app_name": "MyAwesomeApp",
          "port":     "9090",
      }
      
      manager.LoadFromMap(configData)
      fmt.Printf("应用: %s, 端口: %d\n", config.AppName, config.Port)
  }
  ```

  **动态方法调用补全**
  ```go
  // 为Config添加方法
  func (c *Config) UpdatePort(newPort int) (int, int) {
      old := c.Port
      c.Port = newPort
      return old, c.Port
  }
  
  func (c *Config) GetAppInfo() string {
      return fmt.Sprintf("App: %s, Port: %d, Debug: %t", c.AppName, c.Port, c.Debug)
  }
  
  // 在ConfigManager中添加CallMethod实现
  func (cm *ConfigManager) CallMethod(methodName string, args ...interface{}) []interface{} {
      v := reflect.ValueOf(cm.config)
      
      // 如果config不是指针，需要获取指针才能调用指针接收者方法
      if v.Kind() != reflect.Ptr {
          v = v.Addr()
      }
      
      method := v.MethodByName(methodName)
      if !method.IsValid() {
          return []interface{}{fmt.Errorf("方法 %s 不存在", methodName)}
      }
      
      in := make([]reflect.Value, len(args))
      for i, arg := range args {
          in[i] = reflect.ValueOf(arg)
      }
      
      out := method.Call(in)
      results := make([]interface{}, len(out))
      for i, value := range out {
          results[i] = value.Interface()
      }
      
      return results
  }
  
  // 使用示例
  func main() {
      config := &Config{AppName: "TestApp", Port: 8080, Debug: true}
      manager := NewConfigManager(config)
      
      // 调用UpdatePort方法
      results := manager.CallMethod("UpdatePort", 9090)
      if len(results) == 2 {
          oldPort, newPort := results[0].(int), results[1].(int)
          fmt.Printf("端口更新: %d -> %d\n", oldPort, newPort)
      }
      
      // 调用GetAppInfo方法
      results = manager.CallMethod("GetAppInfo")
      if len(results) > 0 {
          appInfo := results[0].(string)
          fmt.Println(appInfo) // 输出: App: TestApp, Port: 9090, Debug: true
      }
  }
  ```

  ### 4. 其他用法

  **动态创建对象**
  ```go
  package main

import (
	"fmt"
	"reflect"
)

type Person struct {
	Name string
	Age  int
}

// 反射创建实例函数
func createInstance(t reflect.Type) interface{} {
	return reflect.New(t).Interface()
}

func main() {
	// 获取Person的类型
	personType := reflect.TypeOf(Person{})
	
	// 使用反射创建Person实例
	instance := createInstance(personType)
	
	// 类型断言为*Person
	if person, ok := instance.(*Person); ok {
		person.Name = "张三"
		person.Age = 25
		fmt.Printf("创建成功: %+v\n", person)
		fmt.Printf("类型: %T\n", person)
	}
}
  ```

---

  ### 5. 课程总结

  1. **反射是什么**：运行时类型检查能力
  2. **核心API**：`TypeOf()`、`ValueOf()`、`MethodByName()`、`Call()`
  3. **应用场景**：框架、配置、ORM、依赖注入
  4. **使用原则**：谨慎使用，注意性能


### 6. 如无必要，不用反射

1. 与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。
2. Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。
3. 反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。