# 同步原语（sync.Mutex互斥锁、sync.WaitGroup等待组、sync.RWMutex读写锁）

### 1. 语法讲解

**为什么需要同步原语？**
在并发编程中，多个goroutine同时访问共享资源时会产生**竞态条件**，导致数据不一致。

**sync.Mutex（互斥锁）**
- 保证同一时间只有一个goroutine能访问共享资源
- 两个方法：`Lock()` 和 `Unlock()`
- 使用后必须释放，否则会导致死锁

**sync.RWMutex（读写锁）**
- 允许多个读操作或一个写操作
- 读锁：`RLock()` / `RUnlock()`（共享锁）
- 写锁：`Lock()` / `Unlock()`（互斥锁）
- 适合"读多写少"的场景

**sync.WaitGroup（等待组）**
- 等待一组goroutine完成工作
- 三个方法：`Add()`、`Done()`、`Wait()`
- 用于协调多个goroutine的执行顺序

```go
var wg sync.WaitGroup

func main() {
    for i := 0; i < 3; i++ {
        wg.Add(1)        // 计数器+1
        go worker(i)
    }
    wg.Wait()           // 等待所有goroutine完成
}
```



### 2. 应用场景

**Mutex适用场景**：
- 银行账户余额更新（防止超额取款）
- 电商库存扣减（防止超卖）
- 计数器累加操作

**WaitGroup适用场景**：
- 批量文件下载，等待所有下载完成
- 并行数据处理，等待所有处理结果
- 服务启动时等待多个初始化任务完成

**RWMutex适用场景**：
- 配置信息读取（频繁读，偶尔更新）
- 缓存系统（大量查询，少量更新）
- 热点数据访问（如商品详情页）

### 3. 编程实例

**电商秒杀库存管理系统**：

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Inventory struct {
    stock    int              // 库存数量
    rwMutex  sync.RWMutex     // 保护库存
}

// 查询库存（使用读写锁的读锁）
func (inv *Inventory) getStock() int {
    inv.rwMutex.RLock()
    defer inv.rwMutex.RUnlock()
    return inv.stock
}

// 扣减库存（使用互斥锁和读写锁的写锁）
func (inv *Inventory) deductStock(userID int, quantity int) bool {
    // 先检查库存（读锁）
    inv.rwMutex.Lock()
    defer inv.rwMutex.Unlock()
	
    // 检查，防止超卖
    if inv.stock < quantity {
        fmt.Printf("用户%d: 库存不足，扣减失败\n", userID)
        return false
    }
    
    inv.stock -= quantity
    fmt.Printf("用户%d: 成功购买%d件，剩余库存%d\n", userID, quantity, inv.stock)
    return true
}

func main() {
    inventory := &Inventory{stock: 10} // 初始库存10件
    
    var wg sync.WaitGroup
    
    // 模拟100个用户同时抢购
    for i := 1; i <= 100; i++ {
        wg.Add(1)
        go func(userID int) {
            defer wg.Done()
            inventory.deductStock(userID, 1)
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("最终库存: %d\n", inventory.getStock())
}
```

### 4. 其他用法
**原子操作替代简单锁**：
```go
import "sync/atomic"

type Counter struct {
    value int64
}

func (c *Counter) Increment() {
    atomic.AddInt64(&c.value, 1) // 比mutex性能更好
}

func (c *Counter) Decrement() {
    atomic.AddInt64(&c.value, -1) 
}

func (c *Counter) Value() int64 {
    return atomic.LoadInt64(&c.value)
}

func main() {
	var counter Counter
    var wg sync.WaitGroup
  
    // 模拟100个用户同时点赞
    for i := 1; i <= 100; i++ {
      wg.Add(1)
      go func() {
          defer wg.Done()
          counter.Increment()
      }()
    }

    // 模拟10个用户取消点赞
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Decrement()
        }()
    }
  
    wg.Wait()
}
```

### 5. 课时总结

- **Mutex互斥锁**：保护临界区，同一时间只允许一个goroutine访问
- **RWMutex读写锁**：读多写少场景下的性能优化
- **WaitGroup等待组**：协调多个goroutine的完成状态

- **使用原则**：
    - 锁的粒度要适中，不要过大或过小
    - 使用defer确保锁的释放
    - 避免在持有锁时进行耗时操作
    - 读写分离场景优先使用RWMutex
    - 简单场景优先使用原子操作